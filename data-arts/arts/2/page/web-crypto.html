<h3>Задачи шифрования</h3>
<p>
    С помощью шифрования решаются следующие задачи:
<ul>
    <li>Конфиденциальность - скрытие информации от посторонних лиц при передаче или при хранении.</li>
    <li>Целостность - предотвращение изменения информации при передаче или хранении.</li>
    <li>Идентифицируемость - аутентификация источника информации и предотвращение отказа отправителя информации
        от того факта, что данные были отправлены именно им.</li>
</ul>
</p>
<h3>Базовые понятия шифрования</h3>
<h4>Симметричные и ассиметричные схемы шифрования</h4>
<p>
    В <b>симметричных схемах</b> для шифрования и расшифровки используется один и тот же криптографический. Главная
    проблема симметричных схем - ключ нельзя передавать по открытому (доступному для наблюдения, незащищенному) каналу,
    т. е. ключ должен сохраняться в секрете обеими сторонами обмена информацией.
</p>
<p>
    В 1977 году были изобретены ассиметричные схемы RSA (аббревиатура от фамилий Rivest, Shamir и Adleman) —
    криптографический алгоритм с открытым ключом, основывающийся на вычислительной сложности задачи факторизации
    больших целых чисел.
</p>
<p>
    В <b>ассиметричных</b> схемах или криптографических системах с <b>открытым ключом</b>, используются два ключа, по одному из
    которых можно только шифровать информацию, а по другому только расшифровывать криптотекс. Открытый ключ (для шифрования)
    не является секретным и его передают по незащищенному каналу, а закрытый ключ для расшифровки хранят в тайне.
    Основной недостаток ассиметричных схем - сложность (ресурсоемкость) решаемой математической задачи подбора ключей
    и операций шифрования/расшифровки, также больший по объему криптотекс для передачи.
</p>

<h4>Хэш</h4>
От любой информации, будь то файл или строка данных, можно вычислить <b>хэш</b>, который может быть представлен в виде
N-символьного (шестнадцатеричного) числа. Хэш обычно меньше исходной информации и часто используется для
проверки целостности (неизменности) информации. При этом хэш-фунции должны удовлетворять следующим требованиям:
<ul>
    <li>Необратимость хэширования: достаточно просто вычислить хэш от исходных данных, но невозможно (за реальное время)
        решить задачу вычисления данных зная хэш</li>
    <li>Стойкость к коллизиям: нет может быть двух одинаковых хэш от разных входных данных (и обратное)</li>
</ul>
<h4>SSL и HTTPS</h4>
<div class="example-img"><img src="/data-arts/arts/2/img/warning.png" style="width: 50%">
    <span>Предупреждения безопасности браузера при использовании самоподписанного сертификата</span>
</div>
<p>
    В WEB задачи безопасного подключения решаются с помощью защищенных протоколов SSL (англ. Secure Sockets Layer —
    уровень защищённых cокетов) и HTTPS (аббр. от англ. HyperText Transfer Protocol Secure) SSL - протокол работает
    на сеансовом уровне, производит генерацию и проверку ключей, шифрование и расшифрование данных (согласно
    модели ISO/OSI), в то время как HTTPS - это обычный протокол HTTP расположенный поверх SSL и использующий порт 443.
</p>
<h5>SSL-сертификаты</h5>
<p>
    Протокол SSL использует сертификаты сервера (сайта) для аутентификации. Сертификат содержит закрытый и
    открытый ключи шифрования и дополнительные данные (кем и кому выдан, назначение, сроки действия сертификата и др.).
</p>
<p>
    Сертификаты защищают пользователя от атак <b>человек по середине</b>, когда злоумышленник может выдавать себя за
    ресурс (сервер) и подсунуть клиенту свой открытый ключ. Тогда дело вступает третья сторона,
    которой доверяют обе стороны обмена секретной информацией - центр сертификации. Браузеры уже содержат сведения о
    доверенных корневых центрах сертификации, и если ваш сертификат выдан одним из них (или его дочкой имеющей право
    выдачи сертификатов), браузер может проверить путь сертификации и убедиться принадлежности открытого ключа
    шифрования запрашиваемому серверу.
</p>
<div class="example-img"><img src="/data-arts/arts/2/img/huck.png" style="width: 60%">
    <span>Пример того как Ева может захватить криптосистему Алисы и Боба даже не взламывая ее. Картинка из Википедии</span>
</div>
<p>
    Изготовить и установить сертификат можно самостоятельно - <b>самоподписанный сертификат</b>, но в таком он не будет
    иметь доверенных издателей и при посещении такого сайта браузер все равно выдаст предупреждение безопасности,
    хотя функции шифрования при этом будут работать как обычно.
</p>
<div class="example-img"><img src="/data-arts/arts/2/img/certs-1.jpg" style="width: 60%">
    <span>Пути сертификации 1) - для одноклассников, 2) - для самоподписанного сертификата</span>
</div>
<h3>Стандарты шифрования. Стойкость алгоритмов SSL</h3>
<p>
    В настоящее время алгоритмы шифрования хорошо изучены, описаны спецификациями и стандартизированы <b>RFC</b>.
</p>
<p>
    Пока не доказано существование необратимых функции шифрования на основе ассиметричных алгоритмов и хэширования,
    задача расшифровки шифротекста является лишь вычислительно сложной. Для алгоритмов RSA можно рассматривать
    только ключи длинной 1024 бита и более. С 31 декабря 2013 года браузеры Mozilla перестали
    поддерживать сертификаты удостоверяющих центров с ключами RSA меньше 2048 бит.
</p>
<h3>Реализация крипто-алгоритмов в Linux и Windows</h3>
<p>
    На Linux наиболее распространённая реализация SSL — криптографический пакет с открытым исходным кодом <b>OpenSSL</b>,
    основанный на SSLeay, написанной Эриком Янгом. Пакет предназначен для создания и управления различного рода
    сертификатами. Также в его состав входит библиотека для поддержки SSL различными программами.
    Библиотека используется, например, модулем SSL в распространенном HTTP-сервере Apache.
</p>
<p>
    В Windows - системах изготовить самоподписанный ssl-сертификат можно с помощью power shall.
</p>
<p>
    Браузеры могут использовать свои криптографические библиотеки, которые не являются открытыми в отличие от Open SSL
    и могут быть защищены авторскими правами:
<ul>
    <li>Google Chrome on Android uses OpenSSL</li>
    <li>NSS (for all firefox and chrome in Linux)</li>
    <li>SChannel (for browsers in Windows)</li>
    <li>Secure Transport (for browsers in Mac OS X)</li>
</ul>
</p>
<!--
HTTPS (аббр. от англ. HyperText Transfer Protocol Secure) — расширение протокола HTTP для поддержки шифрования в целях повышения
безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов SSL или TLS. В отличие от HTTP с TCP-портом 80,
для HTTPS по умолчанию используется TCP-порт 443.[1]
Протокол был разработан компанией Netscape Communications для браузера Netscape Navigator в 1994 году[2].
-->
<h3>Упрощенная схема https соединения</h3>
<p>
    HTTPS для создания защищенного соединения использует ассиметричное шифрование для выработки <b>секретного
    симметричного сессионного ключа</b>, т. е. применяются обе схемы шифрования.
</p>
Не углубляясь в подробности процесса рукопожатий, параметры выработки ключей
 и алгоритмов шифрования рассмотрим упрощенную схему https-подключения:
<ol>
    <li>Вы открываете в браузере сайт https://ok.ru (одноклассники)</li>
    <li>Одноклассники отправляют вашему браузеру сертификат, содержащий открытый ключ</li>
    <li>Ваш браузер проверяет сертификат открытого ключа</li>
    <li>Если сертификат действительный, браузер вырабатывает <b>секретный симметричный сессионный ключ</b>,
    шифрует его открытым ключом сертификата и отправляет на сервер одноклассники</li>
    <li>Сервер ok.ru расшифровывает <b>секретный симметричный сессионный ключ</b> своим закрытым ключом</li>
    <li>Далее трафик между вашем ПК и одноклассниками шифруется более быстрыми симметричными алгоритмами на
        <b>секретном симметричном сессионном ключе</b></li>

</ol>
<h3>Правила шифрования данных пользователя</h3>
<p>
    Из данных пользователя на вашем сайте шифровать следует как минимум пароли, которые не должен знать никто кроме
    пользователя. Но если пароли пользователей совпадут, то совпадет и хэш от них. Для защиты к паролю пользователя
    добавляют случайные данные (криптографическую соль) и уже от их суммы вычисляют хэш и сохраняют соль и хэш в
    базу данных. При авторизации к паролю прибавляют сохраненную соль, вычисляют хэш и сравнивают с сохраненным хэш в
    базе данных. Обычно после сразу создают новую соль и вычисляют новый хэш и обновляют их в БД.
    Таким образом никто кроме пользователя
    не может знать пароль. Проблема восстановления пароля в таком случае решается его сбросом.
</p>
<p>
    На <b>php</b> для хэширования паролей рекомендовано использовать безопасную функцию <b>password_hash</b> с автоматической
    генерацией сложной соли и не требующий раздельного хранения хэш и соли, а для проверки использовать функцию
    <b>password_verify</b>
</p>

<h3>Выводы:</h3>
<p>
    В настоящее время идет тенденция к тому, что все сайты в интернет должны быть безопасными. Более того, ни
    один серьезный ресурс не станет передавать небезопасно на ваш сервер личные данные клиентов (ФИО, паспортные
    данные, банковские реквизиты, логины и пароли и т.п.)
</p>
<p>
    Для передачи конфиденциальной информации необходимо использовать безопасные https-соединения. Только в таком
    случае вы можете быть уверены что данные не будут расшифрованы даже при перехвате их злоумышленниками.
</p>